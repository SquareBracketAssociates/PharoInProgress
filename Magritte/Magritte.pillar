! Magritte: Meta-data at Work

Many applications consist of a large number of input dialogs and reports that need to be built, displayed and validated manually. Often these dialogs remain static after the development phase and cannot be changed unless a new development effort occurs. For certain kinds of application domains such as small businesses, changing business plans, modifying workflows, etc., it usually boils down to minor modifications to domain objects and behavior, for example new fields have to be added, configured differently, rearranged or removed. Performing such tasks is tedious.

Magritte is a meta-data description framework. With Magritte you describe your domain objects and among other things you can get Seaside components and their associated validation for free. Moreover Magritte is self-described, enabling the automatic generation of meta-editors which can be adapted for building end-user customizations of application.

In this chapter we describe Magritte, its design and how to customize it. Now be warned, Magritte is a framework supporting meta-data description. As any framework, mastering it takes time. It is not a scaffolding engine, therefore Magritte may imply some extra complexity and you have to understand when you want to pay for such complexity.

!! Basic Principles

In this section we present the key principles. With such knowledge you can get 80\% of the power of Magritte without knowing all its possible customizations. The key idea behind Magritte is the following: given one object with a set of values, and a description of this information, we will create automatically tools that treat such information and for example automatically create Seaside components. 

Figure *basicPrinciple* shows that a person address', John's address, instance of the class Address, is described by a description object which is attached to the class Address. A program (i.e., database query, generic UI, seaside component builder) will interpret the value of the instance by using its descriptions.

+An object is described by a description which is defined on its class.>file://figures/basicPrinciple.png|width=60%|label=basicPrinciple+

Here are the basic description assumptions:

- An object is described by adding methods named ==description== (naming convention) to its class. Such description methods create different description entities. The following ==MAAddress== class method creates a string description object that has a label 'Street', a priority and two accessors street and street: to access it.

[[[
MAAddress>>descriptionStreet
	<magritteDescription>
	^ MAStringDescription new
		accessor: #street;
		label: 'Street';
		priority: 10;
		yourself
]]]

Note that there is no need to have a one to one mapping between the instance variables of the class and the associated descriptions.

- All descriptions are automatically collected and put into a container description when sending ==description== to  the object (see Figure *describingAddress*).
- Descriptions are defined programmatically and can also be queried. They support the collection protocol (==do:==,  ==select:==...).

+Describing an Address.>file://figures/describingAddress.png|width=90%|label=describingAddress+

""Obtaining a component."" Once an object is described, you can obtain a Seaside component by sending to the object the message ==Object>>asComponent==. For example to get a component for an address: ==anAddress asComponent==.

It is often useful to decorate the component with buttons like cancel and Ok. This can be done by sending the message ==WAComponent>>addValidatedForm== to the component. Note that you can also change the label of the validating form using ==addValidatedForm:== and passing an array of associations whose first element is the message to be sent and the second the label to be displayed.

A Magritte form is generally wrapped with a form decoration via  ==WAComponent>>addValidatedForm==. Magritte forms don't directly work on your domain objects. They work on a memento of the values pulled from your object using the descriptions. When you call ==save==, the values are validated using the descriptions, and only after passing all validation rules are the values committed to your domain object by the momentos via the accessors.

[[[
anAddress asComponent addValidatedForm.
]]]

[[[
anAddress asComponent addValidatedForm: { #save -> 'Save'. #cancel -> 'Cancel' }.
]]]

A description container is an object implementing collection behavior (==collect:==, ==select:==, ==do:==, ==allSatisfy:==, ...). Therefore you can send the normal collection messages to extract the parts of the descriptions you want. You can also iterate over the description or concatenate new ones. Have a look at the ==MAContainer== protocol.

You can also use the message +index:MAContainer!asComponentOn:+ ==MAContainer>>asComponentOn:== with aModel to build or select part of a description and get a component on a given model. The following code schematically shows the idea: two descriptions are assembled and a component based on these two descriptions is built.

[[[
((Address descriptionStreet , Address descriptionPlace) 
	asComponentOn: anAddress) addValidatedForm 
]]]

!! First Example

Let us go over a simple but complete example. We want to develop an application to manage person, address and phone number as shown in Figure *addressOur*.

+Our address design.>file://figures/address.png|width=60%|label=addressOur+ 

We define a class ==MAAddress== with four instance variables and their corresponding accessors. 

[[[
Object subclass: #Address
	instanceVariableNames: 'street place plz canton'
	classVariableNames: ''
	category: 'MaAddress'
]]]

[[[
MAAddress class>>example1
	| address | 
	address := self new.
	address plz: 1001.
	address street: 'Sesame'.
	address place: 'DreamTown'.
	address canton: 'Bern'.
	^ address
]]]

Then we add the descriptions to the ==MAAddress== class as follows: the street name and the place are described by a string description, the PLZ is a number with a range between 1000 and 9999, and since the canton is one of the predefined canton list (our address is for Switzerland so far), we describe it as a single option description.

[[[
MAAddress>>descriptionStreet
		<magritteDescription>
		
		^ MAStringDescription new
			accessor: #street;
			label: 'Street';
			priority: 10;
			yourself
]]]

[[[
MAAddress>>descriptionPlz
		<magritteDescription>
		
		^ MANumberDescription new
			accessor: #plz;
			label: 'PLZ';
			priority: 20;
			min: 1000;
			max: 9999;
			yourself
]]]

[[[
MAAddress>>descriptionPlace
		<magritteDescription>
	
		^ MAStringDescription new
				accessor: #place;
				label: 'Place';
				priority: 30;
				yourself
]]]

[[[
MAAddress>>descriptionCanton
		<magritteDescription>
	
		^ MASingleOptionDescription new
			options: #( 'Zurich' 'Bern' 'Luzern' 'Uri' 'Schwyz' 'Unterwalden' 'Glarus' 'Zug' 'Freiburg' 'Solothurn' 'Basel' 'Schaffhausen' 'Appenzell' 'St. Gallen' 'Graubunden' 'Aargau' 'Thurgau' 'Ticino' 'Vaud' 'Valais' 'Neuchatel' 'Geneve' 'Jura' );
			reference: MAStringDescription new;
			accessor: #canton;
			label: 'Canton';
			priority: 40;
			beSorted;
			yourself
]]]
Now we can start manipulating the descriptions. Inspect the description object of the address object:

[[[
| address |
address := Address example1.
address description inspect.
]]]

Now we can iterate over the descriptions and get the values associated with the descriptions of our address model:

[[[
| address |
address := Address example1.
address description do: [ :description |
	Transcript
		show: description label; show: ':'; tab;
		show: (description toString: (address readUsing: description));
		cr ]
]]]
Executing the second code snippet outputs the following in the Transcript:

[[[
Street:    Sesame
PLZ:       1001
Place:     DreamTown
Canton:    Bern
]]]

""Creating a Seaside Editor."" Now we are ready to create a Seaside component automatically in a similar manner. 

[[[
WAComponent subclass: #MyContactAddress
	instanceVariableNames: 'addressForm'
	classVariableNames: ''
	category: 'MaAddress'
]]]

[[[
MyContactAddress>>initialize
	super initialize.
	addressForm := Address example1 asComponent
]]]

[[[
MyContactAddress>>children
	^ Array with: addressForm
]]]

The method ==asComponent== sent to the address object automatically builds a Seaside component for us. The resulting editor is displayed in Figure *addressUI*.

+Address example1 asComponent.>file://figures/addressUI.png|width=90%|label=addressUI+

To enable validation and add buttons to save and cancel the editing process is a matter of adding a decoration. The message ==addValidatedForm== decorates the component with the necessary rendering and behavior.

[[[
MyContactAddress>>initialize
	super initialize.
	addressForm := Address example1 asComponent.
	addressForm addValidatedForm
]]]

As a result we get a complete address editor, as seen in Figure *addressSaveCancel*.

+Same Magritte generated component with buttons and validation.>file://figures/addressSaveCancel.png|width=90%|label=addressSaveCancel+

In summary Magritte is really easy to use with Seaside. You put your descriptions on the class-side according to a naming-convention. You can then ask your model objects for their descriptions by sending the message ==description== or alternatively you directly ask Magritte to build a Seaside editor for you by sending the message ==asComponent==.
