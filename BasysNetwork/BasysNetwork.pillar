!Basys Network

This chapter presents the Basys package. Basys implements an abstract layer for networks which require bidirectional communication between clients and servers.
Basys manages connections in such a way that sending and receiving data can be performed independently and simultaneously.

Each Basys connection runs its own incoming data loop which processes received data asynchronously. Every received data is processed in a separate thread.

Communication between client and server are equivalent in both directions. There is only one difference: a server should accept connection from a client and it cannot establish new one by itself.


!!Network peers
+A network is a graph of peers.>file://figures/networkAsPeers.jpg|width=50|label=fig:networkAsPeers+

Basys models a network as connected peers (as shown by Figure *@fig:networkAsPeers*). 
Each peer has (sd: is represented by?) its own ==BasysNetwork== instance. It is main class of Basys and should be subclassed by concrete network implementations.

+A peer has a local and remote peers.>file://figures/networkStructure.jpg|width=60|label=fig:networkStructure+

A ==BasysNetwork== instance has ==BasysLocalPeer== (sd:what is has?) instance which represents current local peer. Its purpose is to provide 
some id to be identified between other network peers.

Network remotePeers (sd:is it an instance of BasysNetwork that has an instance varibale that is remotePeers?) is collection of ==BasysRemotePeer== instances which represent currently connected remote peers (as shown in Figure *@fig:peerswithpool*).

+file://figures/peersWithConnectionPool.jpg|width=60|label=fig:peerswithpool+

Peers interact with each others using connection pools.

Any established connection on client is added to peer which represents server. And any established connection to server is added to peer which represents client.

To interact with remote side, a peer retrieves a free connection from pool or establish new if it can. 
Then the retrieved connection is passed to a given action block: (sd: using the message execute:?)

[[[
peer execute: [:connection | connection sendDataPacket: dataObject ].
    "or short version"
peer sendDataPacket: dataObject
]]]

There are two kinds of remote peers: active (==BasysActiveRemotePeer==) and passive (==BasysPassiveRemotePeer==).

+file://figures/typesOfPeers.jpg+

!!!!! Active peers.
Active peers are created by client for a given address using the message ==remotePeerAt:== as follows: 

[[[
peer := network remotePeerAt: (TCPAddress localAt: 40433)
]]]

They establish connection on demand when no one exists in pool or all are busy.

!!!!!Passive peers. 
Passive peers are created by a ==BasysServer== for incoming connections. Server should be started on network:

[[[
network startServerOn: 40433
]]]

To perform requests passive peers are waiting for free connections when all are busy or nothing exists.


!!Peers identification

Basys performs identification procedure for all established connections.
It should ensure that all client connections belong to same peer instance on server and otherwise.
This is what is done in the method ==establishNewConnection==: 

[[[
BasysActivePeer >> establishNewConnection
   connection := network establishNewConnectionTo: address.
   connection acceptIncomingData.
   [ receivedRemotePeerId := network identifyLocalPeerOn: connection.
   self assignId: receivedRemotePeerId receivedFrom: connection ] on: Error do: [:err |
	connection close.
	err pass ].
   ^connection
]]]

Protocol of peer identification is the responsibility of concrete network implementations.

!!!On server side

For every new connection, a BasysServer asks network for new passive peer and sends incoming connection to it. Then a client initiates identification procedure for this connection. It should take care of three cases:
-A server should detect that new connection belongs to existed (sd: existing?) peer. In that case connection should be migrated to existed (sd: existing?) peer and anonymous peer should be removed.
-A server should detect that new peer is connected. Then it should assign to it a correct id which was received from connected client peer.
-At the end, a client should receive peer an id from the connected server.

For the first case, passive peer defines a convenient method named ==beIdentifiedAs:==

[[[
BasysPassivePeer >> beIdentifiedAs: peerId
	| registeredPeer |
	registeredPeer := network 
						remotePeerWithId: peerId 
						ifAbsent: [	id := peerId. ^self ].
	self == registeredPeer ifTrue: [ self error: 'Should not happen' ].
	registeredPeer importConnectionsFrom: connectionPool.
	network removeRemotePeer: self.
	^ registeredPeer
]]]


!!!On client side
A client establishes a new connection to a server. Then it initiates identification procedure. At the end, it receives server peer id. There are two cases here:
- the received peer id belongs to existed (sd: existing? or terminated?) passive peer (if client is server itself and it already accepted connections from server)
- there is no existed (sd: existing? or terminated?) peers with received id

In first case established connection will be migrated to existing peer. Existing peer will become active and the original peer will be removed.

In last case, received id will be assigned to original peer as shown by the method ==assignId:receivedFrom:== method: 

[[[
BasysActivePeer >> assignId: peerId receivedFrom: aBasysConnection
	| registeredPeer |
	id ifNotNil: [
		id = peerId ifFalse: [ self error: 'Peer should not change id when it was already identified' ].
		^self].
	registeredPeer := network remotePeerWithId: peerId ifAbsent: [^id := peerId ].
	registeredPeer addNewConnection: aBasysConnection.
	registeredPeer becomeActiveToReplaceSamePeer: self
]]]

!!Basys implementors
Each application that wants to take advantage of Basys should specialize five hooks. 
Basys implementors should subclass the class ==BasysNetwork== and answer the following five questions:

-What is network data?
-What to do with data?
[[[
process: dataObject receivedFrom: senderPeer
]]]

-How to send data?
[[[
sendDataPacket: dataObject by: aSocket
]]]
-How to receive data?
[[[
receiveIncomingDataPacketFrom: senderPeer by: aSocket
]]]
-How to identify peers?
[[[
identifyLocalPeerOn: aBasysConnection
]]]

Seamless implements these operations to create transparent network of distributed objects.
