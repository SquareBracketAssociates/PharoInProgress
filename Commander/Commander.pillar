{ "title": "Commander. Command pattern library" }

!! Basics

Commander models application actions as first class objects.

Every action is implemented as separate command class (subclass of ==CmdCommand==) with ==#execute== method and all state required for execution.

Commands are reusable objects and applications provide various ways to access them.
Such information is attached to command classes as activator objects. Currently there are three types of activators:
- ==CmdShortcutCommandActivator==
- ==CmdContextMenuCommandActivator==
- ==CmdDragAndDropCommandActivator==

Activators are declared in command class side methods marked with pragma ==#commandActivator==.
For example following method will allow ==RenamePackageCommand== to be executed by shortcut in possible system browser:

[[[
RenamePackageCommand class>>packageBrowserShortcutActivator
  <commandActivator>
  ^CmdShortcutCommandActivator by: $r meta for: PackageBrowserContext
]]]

And for context menu:

[[[
RenamePackageCommand class>>packageBrowserMenuActivator
  <commandActivator>
  ^CmdContextMenuCommandActivator byRootGroupItemFor: PackageBrowserContext
]]]

Activators are always declared with application context where they can be applied (==PackageBrowserContext== in example).
Application should provide such contexts as subclasses of ==CmdToolContext== with information about application state.
Every widget can bring own context to interact with application as separate tool.
For example system browser shows multiple panes which provide package context, class context and method context.
And depending on context browser shows different menu and provides different shortcuts.

To support activators command should implement several methods:
-canBeExecutedInStandardContext: aToolContext
By default it returns true. But usually commands query context for specific information.
For example ==RenamePackageCommand== requires package and it defines this method as:

[[[
RenamePackageCommand>>canBeExecutedInStandardContext: aToolContext
   ^aToolContext isPackageSelected
]]]

-prepareFullExecutionInStandardContext: aToolContext
In this method command should retrieve all state required for execution.
It can also ask user for extra data. For example ==RenamePackageCommand== retrieves package from context and asks user for new name:

[[[
RenamePackageCommand>>prepareFullExecutionInStandardContext: aToolContext
    package := aToolContext selectedPackage.
    newName := UIManager default
        request: 'New name of the package'
        initialAnswer: package name
        title: 'Rename a package'.
    newName isEmptyOrNil | (newName = package name) ifTrue: [ ^ CmdCommandAborted signal ]
]]]

To break execution command can raise ==CmdCommandAborted== signal.

-applyResultInStandardContext: aToolContext
Purpose of this method is to be able interact with application when command completes.
For example if user creates new package from browser then at the end of command browser should open created package:

[[[
CreatePackageCommand>>applyResultInStandardContext: aToolContext
    aToolContext showPackage: resultPackage
]]]

Commands are supposed to be reusable for different contexts and these methods should be implemented with that in mind. They should not discover internal structure of contexts.

Specific context can override activation methods and send own set of messages to command. For example:

[[[
SpecialContextA>>allowsExecutionOf: aCommand
	 ^aCommand canBeExecutedInSpecialContextA: self

SpecialContextA>>prepareFullExecutionOf: aCommand
  aCommand prepareFullExecutionInSpecialContextA: self

SpecialContextA>>applyResultOf: aCommand
  aCommand applyResultInSpecialContextA: self
]]]

By default CmdCommand can implement them with standard context methods. And only particular commands will override them specifically:

[[[
CmdCommand>>prepareFullExecutionInSpecialContextA: aSpecialContextA
  self prepareFullExecutionInStandardContext: aSpecialContextA

SomeCommand>>prepareFullExecutionInSpecialContextA: aSpecialContextA
  "special logic to prepare command for execution"
]]]

The way how concrete type of activator hooks into application is responsibility of application. Look at related sections for details on concrete activator.

In future Commander will provide deep integration with UI. And many things can work automatically.

!! Command execution

Context instances are used to perform command lookup.
For example following expression will enumerate all shortcut activators relevant to package pane of possible browser:

[[[
CmdShortcutCommandActivator
  allDeclaredFor: aPackageBrowserContext
  do: [:declaredActivator | ]
]]]

Declared activator is not ready for execution. It should create new activator instance for this:

[[[
readyActivator := declaredActivator newActivationFor: aPackageBrowserContext
]]]

Ready activator is bound to given context and it keeps new command instance. To execute command evaluate:

[[[
readyActivator executeCommand
]]]

Before execution users should check that it is possible:

[[[
activator canExecuteCommandInContext: aPackageBrowserContext
]]]

There is convinient method to enumeration only executable commands:

[[[
CmdShortcutCommandActivator
  allExecutableIn: aPackageBrowserContext
  do: [:readyActivator | ]
]]]

!! Abstract menu activation
@abstractMenuActivation

There are a lot of different types of menu: context menu, toolbar, morphic halo menu and etc..
All of them are very similar: they show set of items to the user and when user selects one the action associated with item is evaluated.
Only difference between them is the way how they are represented to user and where they are shown in application.

Commander allows build different kind of menus based on commands and first class groups.
Concrete type of menu is represented by concrete type of activator, subclass of CmdMenuCommandActivator.
These activators mark commands to be part of menu:

[[[
YourCommand>>yourAppMenuActivator
  <commandActivator>
  ^ConcreteMenuCommandActivator byItemOf: YourAppChildMenuGroup for: YourAppContext
]]]

Activator provides information about name, group and position of command inside menu:
- ==menuItemName== (by default it is retrieved from command instance by ==#defaultMenuItemName==).
- ==menuItemOrder== (larger value pushes command to the end of menu)
- ==menuGroup== (root by default)

To set up these properies there are few instance creation methods:
- ==byRootGroupItemFor: YourAppContext==
- ==byRootGroupItemOrder: aNumber for: YourAppContext==
- ==byItemOf: menuGroupClass for: YourAppContext==
- ==byItemOf: menuGroupClass order: aNumber for: YourAppContext==

==CmdMenu== represents abstract tree structure for concrete menu implementation:

[[[
menu := CmdMenu activatedBy: aCommandActivatorClass
]]]

It builds command and group items using information from activators declared for given context:

[[[
menu buildInContext: aToolContext
]]]

This method can be called multiple times for different contexts. It allows to build single menu for multiple parts of application.
For example toolbar menu can include commands for all visible widgets.

Menu groups are represented by subclasses of CmdMenuGroup. They are used as classes to declare activators. Instances are only created during menu building.

Groups are containers of command items and other groups. They define following methods to describe menu structure:
- ==parentGroup== on class side. By default it is CmdRootMenuGroup. Subclasses override it to define deep tree structure.
- ==order== on instance side. Larger values pushed group to the end of menu
- ==name== on instance side. It should be shown to user in concrete menu implementation.

Concrete menu activators extend menu objects and commands with specific methods to build concrete view elements. For example look at next section.

!! Context menu command activation

To add commands into context menu use ==CmdContextMenuCommandActivator== (more detailes at *@abstractMenuActivation*). For example:

[[[
RenamePackageCommand class>>packageBrowserMenuActivator
  <commandActivator>
  ^CmdContextMenuCommandActivator byRootGroupItemFor: PackageBrowserContext
]]]

To build context menu morph use following expression:

[[[
menu := CmdContextMenuCommandActivator buildMenuFor: anAppMorph inContext: aToolContext
]]]

Context menu extends command with menu building method:

[[[
CmdCommand>>fillContextMenu: aMenu using: anActivator
]]]

It creates menu item morph and allows subclasses to define default label and icon:

- ==defaultMenuItemName==
- ==setUpIconForMenuItem: aMenuItemMorph==

Subclasses can override building method to represent themselves differently. For example they can create menu item with check box.

!! Shortcut command activation

To mark commands with shortcuts use CmdShortcutCommandActivator. For example:

[[[
RenamePackageCommand class>>packageBrowserShortcutActivator
  <commandActivator>
  ^CmdShortcutCommandActivator by: $r meta for: PackageBrowserContext
]]]

There are extra instance creation methods for standard shortcuts:
- ==renamingFor: aToolContext==
- ==removalFor: aToolContext==

To support shortcuts based on commands application should define specific kmDispatcher for target morphs:

[[[
YourAppMorph>>kmDispatcher
  ^CmdKMDispatcher attachedTo: self
]]]

with supporting method:

[[[
YourAppMorph>>createCommandContext
  ^YourAppContext for: self
]]]

!! Drag and drop command activation

Drag and drop command activation is different than others.
To prepare command it needs two contexts. First context describes the place where drag was started. Second context describes drop target tool.
So activator prepares command execution in both contexts. They bring different information.
And together they are supposed to provide all required data for command execution without extra user requests.

According to this logic commands should define following supporting methods when they want drag and drop:

- ==prepareExecutionInStandardDragContext: aToolContext==
- ==prepareExecutionInStandardDropContext: aToolContext==
- ==canBeExecutedInStandardDropContext: aToolContext==

Also specific contexts can define own set of activation methods:

[[[
SpecialContextA>>allowsDropExecutionOf: aCommand
  ^aCommand canBeExecutedInSpecialDropContextA: self

SpecialContextA>>prepareDragActivationOf: aCommand
	aCommand prepareExecutionInSpecialDragContextA: self

SpecialContextA>>prepareDropExecutionOf: aCommand
	aCommand prepareExecutionInSpecialDropContextA: self
]]]


To activate commands with drag and drop use ==CmdDragAndDropCommandActivator==. For example:

[[[
MoveMethodToClassCommand class>>methodBrowserDragAndDropActivator
  <commandActivator>
  ^CmdDragAndDropCommandActivator for: MethodBrowserContext toDropIn: ClassBrowserContext
]]]

And supporting methods would be:

[[[
MoveMethodToClassCommand>>prepareExecutionInStandardDragContext: aToolContext
  super prepareExecutionInStandardDragContext: aToolContext.
  methods := aToolContext selectedMethods

MoveMethodToClassCommand>>prepareExecutionInStandardDropContext: aToolContext
    super prepareExecutionInStandardDropContext: aToolContext.
    targetClass := aToolContext selectedClass
]]]
