! TinyChatPharo permet la définition en quelques dizaines de lignes un server REST grace au package Teapot qui étend Zinc le superbe client/server HTTP de Pharo développer par la société BetaNine est offert gracieusement à la communauté. L'objectif de ce chapitre est de vous faire développer en cinq classes une application de chat client/server avec un client graphique. Cette petite aventurevous permettra de vous familiariser avec Pharo et de voir l'aisance avec laquelle un server REST peut etre défini. TinyChat qui a été développé par Olivier Auverlot reste cependant une application pédagogique. !! Objectives et architectureNous allons donc construire un serveur de discussion (chat) et un client permettant de s'y connecter. La communication entre le client et le serveur sera basée sur HTTP et REST.En plus des classes, ==TCServer== et ==TinyChat== qui sera le client nous définirons trois autres classes: la classe ==TCMessage= qui représente les messages échangés (dans le future vous pourrez étendre TinyChat pour échanger des éléments plus structurés comme JSON ou STON le format textuel Pharo.), la classes ==TCMessageQueue== qui garde les messages !! Chargeons TeapotVous pouvez charger Teapot soit en utilisant le ConfigurationBrowser qui se trouve dans le menu Tools du menu principal. Sélectionnez Teapot et utiliser "Install Stable".Sinon vous pouvez aussi utiliser le script suivant:[[[Gofer it    smalltalkhubUser: 'zeroflag' project: 'Teapot';    configuration;    loadStable.]]]!! Représentation d'un messageUn message est un objet hyper simple avec un text et un identifiant de l'émetteur. !!! Créez la classe TCMessage dans le package TinyChat[[[Object subclass: #TCMessage	instanceVariableNames: 'sender text separator'	classVariableNames: ''	category: 'TinyChat']]]- sender: le login de l'expéditeur- text: le texte du message- separator: un caractère séparateur pour l'affichage!!! Créez les accesseurs pour les variables d'instance ==sender== et ==text==[[[TCMessage>>sender	^ senderTCMessage>>sender: anObject	sender := anObjectTCMessage>>text	^ textTCMessage>>text: anObject	text := anObject]]]!!! Initialisation de la classeLa méthode ==initialize== fixe la valeur du caractère séparateur.[[[TCMessage>>initialize	super initialize.	separator := '>'.]]]La méthode de classe ==TCMessage class>>from:text:== permet d'instancier un message :[[[TCMessage class>>from: aSender text: aText	^ self new sender: aSender; text: aText; yourself]]]Le message ==yourself== rend le receveur du message: c'est une manière de s'assurer que le nouvel objet créé serabien retourné par le message ==from:text:== et non le résultat du message ==text:==. !!! Convertir un message en chaîne de caractèresDéfinissons [[[TCMessage>>toString	^String streamContents: [ :stream |		stream 			<< self sender; 			<< separator; 			<< self text; 			<< String crlf	]]]]!! Construire un message à partir d'une chaîne de caractèresNous pouvons définir aussi deux méthodes pour créer un message à partir d'une chaine ayant la forme: 'olivier>tinychat est cool'.Tout d'abord une méthode de classe qui sera invoquée de la manière suivante: TCMessage fromString: 'olivier>tinychat est cool'.Suivi de la méthode d'instance remplissant les variables de l'objet préalablement créé. [[[TCMessage class>>fromString: aString	^ self new 		fromString: aString;		yourself]]][[[TCMessage >> fromString: aString	"Compose a message from a string of this form 'sender>message'."	| items |	items := aString subStrings: separator.	self sender: items first.	self text: items second.]]]Maintenant nous sommes prêt pour définir le serveur. !!Le serveurPour le serveur nous ###Stockage des messagesCréez la classe TCMessageQueue dans la catégorie TinyChat-Server[[[Object subclass: #TCMessageQueue	instanceVariableNames: 'messages'	classVariableNames: ''	category: 'TinyChat-server'[[[La variable d'instance messages est une collection ordonnée donc le contenu est composé d'instances de TCMessage.[[[initialize	super initialize.	messages := OrderedCollection new.[[[####Opérations de bases sur la liste des messagesOn doit pouvoir ajouter un message (#add:), effacer la liste (#reset) et connaître le nombre de messages (#size).[[[add: aMessage	messages add: aMessage reset	messages removeAllsize	^messages size[[[!!!!Obtenir la liste des messages à partir d'une positionLorsqu'un client demande au serveur la liste des derniers messages échangés, il indique au serveur l'index du dernier message qu'il connaît. Le serveur répond alors la liste des messages reçus depuis cet index.[[[listFrom: aIndex	^ (aIndex > 0 and: [ aIndex <= messages size]) 		ifTrue: [ messages copyFrom: aIndex to: messages size ]		ifFalse: [ #() ]]]]!!!!Formatage des messagesLa classe TCMessageQueue doit pouvoir formater une liste de messages (à partir d'un index) en une chaîne de caractères que le serveur pourra transmettre au client. Dans la classe TCMessage, on ajoute une méthode #toString pour transformer le message en une chaîne de caractères.Modèle de la chaîne: sender-separator-text-crlfExemple: 'john>hello !!!'[[[TCMessageQueue >> toString	^String streamContents: [ :stream |		stream 			<< self sender; 			<< separator; 			<< self text; 			<< String crlf ]]]]On ajoute ensuite une méthode à la classe TCMessageQueue pour construire une seule chaine de caractères à partir de chaque chaîne de caractères produit par chaque message:[[[TCMessageQueue >> formatedMessagesFrom: aMessageNumber		^ String streamContents: [ :formatedMessages |  		(self listFrom: aMessageNumber) 			do: [ :m | formatedMessages nextPutAll: m toString ] 		]]]]!!! Le Serveur de Chat !!! Créez la classe TCServer dans le package TinyChat-Server[[[Object subclass: #TCServer	instanceVariableNames: 'teapotServer messagesQueue'	classVariableNames: ''	category: 'TinyChat-Server']]]La variable d'instance ==messagesQueue== référence la liste des messages reçus et envoyés par le serveur. [[[TCServer >> initialize	super initialize.	messagesQueue := TCMessageQueue new.]]]La variable d'instance ==teapotServer== référence l'instance du serveur TeaPot que l'on créée à l'aide de la méthode ==initializePort:==[[[TCServer >> initializePort: anInteger	teapotServer := Teapot configure: { 		#defaultOutput -> #text.		#port -> anInteger.		#debugMode -> true	}.	teapotServer start.]]]Le routage HTTP est défini dans la méthode ==registerRoutes==. Trois opérations sont définies :- GET ==messages/count== : retourne au client le nombre de messages reçus par le serveur,- GET ==messages/<id:IsInteger>== : le serveur retourne les messages à partir de l'index indiqué dans la requête HTTP,- POST ==/message/add== : le client envoie un message au serveur. [[[TCServer >> registerRoutes	teapotServer		GET: '/messages/count' -> (Send message: #messageCount to: self);		GET: '/messages/<id:IsInteger>' -> (Send message: #messagesFrom: to: self);		POST: '/messages/add' -> (Send message: #addMessage: to: self)]]]Nous exprimons ici que le chemin message/count va donner lieu à l'execution du message ==messageCount== sur le serveur lui-même.@@explain id:La gestion des erreurs est définie dans la méthode ==registerErrorHandlers==.[[[TCServer >> registerErrorHandlers	teapotServer		exception: KeyNotFound -> (TeaResponse notFound body: 'No such message')]]]Le démarrage du serveur est confié à la méthode ==TCServer class>>startOn:== qui reçoit le numéro de port TCP en paramètre.[[[TCServer class>>startOn: aPortNumber	^self new		initializePort: aPortNumber;		registerRoutes;		registerErrorHandlers;		yourself]]]Il faut également gérer l'arrêt du serveur. La méthode ==stop== met fin à l'exécution du serveur TeaPot et vide la liste des message.[[[TCServer >> stop	teapotServer stop.	messagesQueue reset.]]]Comme il est probable que vous executiez plusieurs fois l'expression ==TCServer startOn:==, nous définissons la méthode de classe ==stopAll== qui stoppe tous les serveursen récuperant toutes les instance de la classe.  La méthode ==TCServer class>>stopAll== demande l'arrêt de chaque instance du serveur.[[[TCServer class >> stopAll	self allInstancesDo: #stop]]]!!! Traitements réalisés par le serveurLa méthode ==addMessage== extrait de la requête du client le message posté. Elle ajoute à la liste des messages une nouvelle instance de ==TCMessage==.[[[TCServer >> addMessage: aRequest	messagesQueue add: (TCMessage from: (aRequest at: #sender) text: (aRequest at: #text)).]]]La méthode ==messageCount== retourne le nombre de messages reçus.[[[TCServer >> messageCount	^ messagesQueue size]]]La méthode ==messageFrom:== retourne la liste des messages reçus par le serveur depuis l'index indiqué par le client. Les messages sont retournés au client sous la forme d'une chaine de caractères. Ce point sera définitevement à améliorer. [[[TCServer >> messagesFrom: request	^ messagesQueue formatedMessagesFrom: (request at: #id)  ]]]Nous en avons fini avec le server.!! Le clientLe client se compose de deux classes:- TinyChat est la classe contenant la logique métier (connexion, envoi et réception des messages),- TCConsole est une classe définissant l'interface graphique.Au lancement du client, celui-ci demande au serveur l'index du dernier message reçu.Toutes les deux secondes, le client se connecte au serveur pour lire les messages échangés depuis sa dernière connexion. Pour cela, il transmet au serveur l'index du dernier message dont il a eu connaissance.Lorsque le client transmet un message au serveur, il en profite pour également lire les messages échangés depuis sa dernière connexion.!!!! Créez la classe TinyChat dans la catégorie TinyChat-Client[[[Object subclass: #TinyChat	instanceVariableNames: 'url login exit messages console lastMessageIndex'	classVariableNames: ''	category: 'TinyChat-client'[[[- url contient l'url HTTP permettant au client de se connecter au serveur,- login est une chaîne de caractères identifiant le client,- messages est une variable d'instance contenant les messages lus par le client,- lastMessageIndex est le numéro du dernier message lu par le client,- exit est une valeur booléenne. Tant que cette valeur est vraie, le client se connecte à intervalle régulier au serveur pour lire les messages échangés depuis sa dernière connexion,- console pointe sur l'instance de la console graphique permettant à l'utilisateur de saisir et de consulter les messages.[[[TinyChat >> initialize	super initialize.	exit := false.	lastMessageIndex := 0.	messages := OrderedCollection new.[[[!!!! Définir les commandes HTTPDans le protocole command, les opérations du protocole HTTP sont définies.Deux méthodes permettent de formater la requête. L'une n'a pas d'argument et permet de construire les requêtes /messages/add et /messages/count. L'autre a une argument qui sera utilisé pour la lecture des messages à partir d'une position.[[[command: aPath	^'{1}{2}' format: { url . aPath }command: aPath argument: anArgument	^'{1}{2}/{3}' format: { url . aPath . anArgument asString }[[[Il suffit ensuite de définir les trois commandes HTTP du client:[[[cmdLastMessageID	^ self command: '/messages/count'cmdNewMessage	^self command: '/messages/add'cmdMessagesFromLastIndexToEnd	"Returns the server messages from my current last index to the last one on the server."	^ self command: '/messages' argument: lastMessageIndex[[[!!!!Gérer les opérations du clientLa méthode #readLastMessageID retourne l'index du dernier message reçu par le serveur.[[[readLastMessageID	| id |	id := (ZnClient new url: self cmdLastMessageID; get) asInteger.	id = 0 ifTrue: [  id := 1 ].	^ id[[[La méthode #readMissingMessages ajoute les derniers messages reçus par le serveur à la liste des messages connus par le client. Cette méthode retourne le nombre de messages récupérés.[[[readMissingMessages	"Gets the new messages that have been posted since the last request."	| response receivedMessages |	response := (ZnClient new url: self cmdMessagesFromLastIndexToEnd; get).	^ response 		ifNil: [ 0 ]		ifNotNil: [  			receivedMessages := response subStrings: (String crlf).			receivedMessages do: [ :msg | messages add: (TCMessage fromString: msg) ].			receivedMessages size.		].[[[La méthode #refreshMessages utilise un thread pour lire à intervalle régulier les messages reçus par le serveur. Le délai est fixé à deux secondes.[[[refreshMessages	[  		[ exit ] whileFalse: [  			(Delay forSeconds: 2) wait.			lastMessageIndex := lastMessageIndex + (self readMissingMessages).			console print: messages.		]	] fork[[[La méthode #sendNewMessage: poste le message de l'utilisateur au serveur.[[[sendNewMessage: aMessage	^ ZnClient new		url: self cmdNewMessage;		formAt: 'sender' put:  (aMessage sender);		formAt: 'text' put: (aMessage text);		post[[[Cette méthode est utilisée par la méthode #send: qui reçoit en paramètre le texte saisi par l'utilisateur. La chaine de caractères est alors convertie en une instance de TCMessage. Le message est envoyé. Le client met à jour l'index du dernier message connu et déclenche l'affichage du message dans l'interface graphique.[[[send: aString	"When we send a message, we push it to the server and in addition we update the local list of posted messages."		| msg |	(aString isNotEmpty) ifTrue: [ 		msg := TCMessage from: login text: aString.		self sendNewMessage: msg.		lastMessageIndex := lastMessageIndex + (self readMissingMessages).		console print: messages.	][[[La déconnexion du client est géré par la méthode #disconnect qui envoie un message au serveur pour signaler le départ de l'utilisateur et met fin à la boucle de récupération périodique des messages.[[[disconnect	self sendNewMessage: (TCMessage from: login text: 'I exited from the chat room.').	exit := true[[[####Fixer les paramètres du clientPour initialiser les paramètres de connexion, on définit une méthode TinyChat class>>connect:port:login:. Cet méthode permet de se connecter avec la syntaxe suivante:TinyChat connect: 'localhost' port: 8080 login 'username'[[[TinyChat class>>connect: aHost port: aPort login: aLogin	^ self new		host: aHost port: aPort login: aLogin;		start[[[Le code appelle la méthode #host:port:login:. Cette méthode met à jour la variable d'instance url en construisant l'URL et en affectation le nom de l'utilisateur à la variable d'instance login.[[[host: aHost port: aPort login: aLogin	url := 'http://' , aHost , ':' , aPort asString.	login := aLogin[[[La méthode #start envoie un message au serveur pour présenter l'utilisateur, récupère l'index du dernier message reçu par le serveur et met à jour la liste des messages connus par le client. C'est également cette méthode qui initialise l'interface graphique de l'utilisateur.[[[start	console := TCConsole attach: self.			self sendNewMessage: (TCMessage from: login text: 'I joined the chat room').	lastMessageIndex := self readLastMessageID.	self refreshMessages.[[[####Créez la classe TCConsole dans la catégorie TinyChat-ClientL'interface graphique est composée d'une fenêtre contenant une liste et un champ de saisie. [[[ComposableModel subclass: #TCConsole	instanceVariableNames: 'chat list input'	classVariableNames: ''	category: 'TinyChat-client'[[[La variable d'instance chat est une référence à une instance de la classe TinyChat et nécessite uniquement un accesseur en écriture (setter). Les variables d'instance list et input dispose chacune d'un accesseur en lecture (getter). [[[input	^ inputlist	^ listchat: anObject	chat := anObject[[[L'interface graphique a un titre pour la fenêtre. Pour le fixer, il faut écrire une méthode #title.[[[title	^ 'TinyChat'[[[La méthode TCConsole class>>attach: reçoit en argument l'instance du client de chat avec lequel l'interface graphique va être utilisée. Cette méthode déclenche l'ouverture de la fenêtre et met en place l'événement gérant la fermeture de celle ci et donc, provoquant la déconnexion du client. [[[TCConsole class>>attach: aTinyChat	| window |	window := self new chat: aTinyChat.	window openWithSpec whenClosedDo: [ aTinyChat disconnect ].	^window[[[La méthode TCConsole class>>defaultSpec définie la mise en page des composants contenus dans le fenêtre.[[[TCConsole class>>defaultSpec	<spec: #default>    	^ SpecLayout composed		newColumn: [ :c | 			c				add: #list;				add: #input height: 30			];		yourself[[[La méthode #initializeWidgets spécifie la nature et le comportement des composants graphiques[[[initializeWidgets	list := ListModel new.		input := TextInputFieldModel new 		ghostText: 'Type your message here...';		enabled: true;		acceptBlock: [ :string |  			chat send: string. 			input text: '' ].		self focusOrder add: input.[[[La méthode #print affiche les messages reçus par le client en les affectant au contenu de la liste.[[[print: aCollectionOfMessages	list items: (aCollectionOfMessages collect: [  :m |  m toString ])[[[##Quelques améliorations possibles* Gestion des erreurs de connexion,* Obtenir la liste des personnes connectées,* Pouvoir fixer le délai de récupération des messages,* Utiliser JSON pour le transport des messages